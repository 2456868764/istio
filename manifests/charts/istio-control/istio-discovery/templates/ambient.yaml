{{- if not (eq .Values.meshConfig.ambientMesh.mode "OFF") }}
apiVersion: v1
kind: ServiceAccount
  {{- if .Values.global.imagePullSecrets }}
imagePullSecrets:
  {{- range .Values.global.imagePullSecrets }}
  - name: {{ . }}
  {{- end }}
  {{- end }}
metadata:
  name: uproxy
  namespace: {{ .Release.Namespace }}
  labels:
    app: uproxy
    release: {{ .Release.Name }}
---
{{- if eq .Values.uproxyType "aws" }}
# not needed long term, just for aws until we fix token request logic
# https://github.com/kubernetes/kubernetes/blob/1e7fa3478ed9de606b761be4f70be4ca60e6e697/plugin/pkg/auth/authorizer/node/node_authorizer.go#L223
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: add-on-cluster-admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: uproxy
    namespace: {{ .Release.Namespace }}
---
{{- end }}
{{- $iptablesRedirect := or (eq .Values.uproxyType "kind") (eq .Values.uproxyType "aws") }}
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: uproxy
  namespace: {{ .Release.Namespace }}
  labels:
{{- range $key, $val := .Values.uproxy.deploymentLabels }}
    {{ $key }}: "{{ $val }}"
{{- end }}
spec:
  selector:
    matchLabels:
      app: uproxy
  template:
    metadata:
      labels:
        sidecar.istio.io/inject: "false"
        app: uproxy
{{- if $iptablesRedirect }}
        ambient-type: uproxy
{{- else }}
        asm-type: proxy
{{- end }}
        {{- range $key, $val := .Values.uproxy.podLabels }}
        {{ $key }}: "{{ $val }}"
        {{- end }}
      annotations:
        sidecar.istio.io/inject: "false"
        {{- if .Values.uproxy.podAnnotations }}
{{ toYaml .Values.uproxy.podAnnotations | indent 8 }}
        {{- end }}
    spec:
      serviceAccountName: uproxy
      initContainers:
      - name: istio-init
{{- if contains "/" .Values.uproxy.image }}
        image: "{{ .Values.uproxy.image }}"
{{- else }}
        image: "{{ .Values.uproxy.hub | default .Values.global.hub }}/{{ .Values.uproxy.image | default "proxyv2" }}:{{ .Values.uproxy.tag | default .Values.global.tag }}"
{{- end }}
        securityContext:
          privileged: true
          capabilities:
            add:
            - NET_ADMIN
        command:
          - sh
          - -c
{{- if $iptablesRedirect }}
          - |
            # With normal linux routing we need to disable the rp_filter
            # as we get packets from a tunnel that doesn't have default routes.
            echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
            echo 0 > /proc/sys/net/ipv4/conf/default/rp_filter
            echo 0 > /proc/sys/net/ipv4/conf/eth0/rp_filter
{{- else }}
          - |
            # HBONE traffic goes to HBONE port...
            iptables -t nat -A PREROUTING -p tcp --dport 15008 ! -s $INSTANCE_IP ! -d $INSTANCE_IP  -j LOG --log-prefix="[howardjohn 15008] "
            iptables -t nat -A PREROUTING -p tcp --dport 15008 ! -s $INSTANCE_IP ! -d $INSTANCE_IP  -j REDIRECT --to-ports 15008
            # Special logic to handle the case where we have a remote proxy (no interception) and server (interception) on the node
            # Without this, packets from remote proxy -> server would not go through uProxy, but the response would, causing breakage.
            # This ensures the response does not go through uProxy
            iptables -t nat -A PREROUTING -m state --state NEW -p tcp --tcp-flags ACK ACK ! -s $INSTANCE_IP ! -d $INSTANCE_IP  -j LOG --log-prefix="[howardjohn remote] "
            iptables -t nat -A PREROUTING -m state --state NEW -p tcp --tcp-flags ACK ACK ! -s $INSTANCE_IP ! -d $INSTANCE_IP  -j ACCEPT
            # Send everything else through the "outbound" port. For now, DPv2 cannot distinguish inbound vs outbound, so we
            # do some (semi-reliable) heuristics on the outbound port to treat it as inbound, when needed. Typically inbound is
            # HBONE though.
            iptables -t nat -A PREROUTING -p tcp ! -s $INSTANCE_IP ! -d $INSTANCE_IP  -j LOG --log-prefix="[howardjohn outbound] "
            iptables -t nat -A PREROUTING -p tcp ! -s $INSTANCE_IP ! -d $INSTANCE_IP  -j REDIRECT --to-ports 15001

            iptables -t nat -I OUTPUT 1 -p tcp --dport 15088 -j LOG --log-prefix="[howardjohn local] "
            iptables -t nat -I OUTPUT 1 -p tcp --dport 15088 -j REDIRECT --to-port 15008
{{- end }}
        env:
        - name: INSTANCE_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        {{- if .Values.uproxy.env }}
        {{- range $key, $val := .Values.uproxy.env }}
        - name: {{ $key }}
          value: "{{ $val }}"
        {{- end }}
        {{- end }}
      containers:
      - name: istio-proxy
{{- if contains "/" .Values.uproxy.image }}
        image: "{{ .Values.uproxy.image }}"
{{- else }}
        image: "{{ .Values.uproxy.hub | default .Values.global.hub }}/{{ .Values.uproxy.image | default "proxyv2" }}:{{ .Values.uproxy.tag | default .Values.global.tag }}"
{{- end }}
{{- if .Values.global.imagePullPolicy }}
        imagePullPolicy: {{ .Values.global.imagePullPolicy }}
{{- end }}
        securityContext:
          capabilities:
            add:
            - NET_ADMIN
        readinessProbe:
          httpGet:
            port: 15020 # TODO: use 15021, but it spams logs
            path: /healthz/ready
        args:
        - proxy
        - sidecar
        env:
        - name: ISTIO_META_GENERATOR
          value: "uproxy-envoy"
        - name: ISTIO_META_SIDECARLESS_TYPE
          value: "uproxy"
        - name: ISTIO_META_CLUSTER_ID
          value: {{ .Values.global.multiCluster.clusterName | default "Kubernetes" }}
        - name: CREDENTIAL_FETCHER_TYPE
          value: "TokenRequest"
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: ISTIO_META_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: INSTANCE_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: SERVICE_ACCOUNT
          valueFrom:
            fieldRef:
              fieldPath: spec.serviceAccountName
        {{- if .Values.uproxy.env }}
        {{- range $key, $val := .Values.uproxy.env }}
        - name: {{ $key }}
          value: "{{ $val }}"
        {{- end }}
        {{- end }}
        volumeMounts:
        - mountPath: /var/run/secrets/istio
          name: istiod-ca-cert
        - mountPath: /var/run/secrets/tokens
          name: istio-token
        - mountPath: /var/lib/kubelet/pki # Must match due to symlinks...
          name: kubelet-creds
{{- if not $iptablesRedirect }}
        securityContext:
          privileged: true
          capabilities:
            add:
            - NET_ADMIN
{{- end }}
      volumes:
      - name: kubelet-creds
        hostPath:
          path: /var/lib/kubelet/pki
      - name: istio-token
        projected:
          sources:
          - serviceAccountToken:
              path: istio-token
              expirationSeconds: 43200
              audience: istio-ca
      - name: istiod-ca-cert
        configMap:
          name: istio-ca-root-cert

{{- end }}
